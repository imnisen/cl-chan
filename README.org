#+OPTIONS: toc:nil
* Cl-Chan 

** Usage
~cl-chan~ provides a golang-like channel stuff. It provides two types channel: ~unbuffered-channel~ and ~buffered-channel~. 

#+BEGIN_SRC lisp
;; make a unbuffered channel
CL-CHAN> (defvar *c1* (make-channel))
*C1*


;; make a buffered channel with size 2.
CL-CHAN> (defvar *c2* (make-channel :buffered t :size 2))
*C2*
#+END_SRC

You can use ~send~ to send value to a channel or ~recv~ to receive value from it.

#+BEGIN_SRC 
;; return value is channel itself
CL-CHAN> (send *c2* 1)
#<BUFFERED-CHANNEL {100285CD33}>

;; first return value is value received from channel
;; second return value is channel itself
CL-CHAN> (recv *c2*)
1
#<BUFFERED-CHANNEL {100285CD33}>

#+END_SRC

Also there is a ~select~ which could be used to wait one of multi channels events to happen.
#+BEGIN_SRC 

(select
   ((recv c d)
    (format t "got ~a from c~%" d))
   ((send e val)
    (print "sent val on e~%"))
   ((recv *lots-of-channels* value channel)
    (format t "Got ~A from ~C~%" value channel))
   (otherwise
    (print "would have blocked~%")))

#+END_SRC


Note, This project is currerently a prototype which I steal many ideas from [[https://github.com/zkat/chanl][chanl]] and [[https://github.com/tylertreat/chan][chan]].

However, in project chanl, I found the unbuffered channel may cause race condition which is not fixed ([[https://github.com/zkat/chanl/issues/13][issue]]).

In project chan, I found the select implenmentation may have a problem ([[https://github.com/tylertreat/chan/issues/26][issue]]).

Basically, this version of channel implenmentation is almost same as project chan one. So the select may have problem also.

I will try fix it in a while which may introduce a blockp paramter to recv/send.


** Installation
Download the repo in where your quicklisp can find (such as ~~/quicklisp/local-projects~), then use ~(ql:quickload :cl-chan)~ to install.

** Author

+ Nisen (imnisen@gmail.com)

** Copyright/License

Do whatever you want.

** TODOS                                                                        :noexport:

*** DONE add buffered channel
    CLOSED: [2019-10-08 Tue 15:16]
    :LOGBOOK:
    - State "DONE"       from              [2019-10-08 Tue 15:16]
    :END:
- check how the queue is make?
*** DONE add select
    CLOSED: [2019-10-08 Tue 15:16]
    :LOGBOOK:
    - State "DONE"       from              [2019-10-08 Tue 15:16]
    :END:
*** TODO may select has a bug, first can recv/send, then recv/send it fails and block. what to do?
The problem is due to check and actually send/recv is not guaranteed to be consistent.
So if channel can send/recv, don't release the lock, get the value also.

Steps:
1. add send/recv blockp feature.

2. change select select logic:
first random choose a channel to send/recv, use (send/recv blockp nil), if success return, else choose another one.

Maybe let's check how golang implement send,recv and select?

*** port other chanl rest concepts
*** port chan.c other funcs
*** write test case
*** refactor readers,writers to readers-waiting, writers-waiting
*** select implenmentation use `eval`, consider trying another method to avoid it?
*** Do we need close and init of channel?
*** can we abstract concepts like chanl?
*** Add documentation of methods.
*** Refactor name.
*** Export useful functions from other file
